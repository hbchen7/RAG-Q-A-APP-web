# 首屏速度、白屏时间
![[asset/Pasted image 20250325145715.png]]
## 资源加载时间->减少首屏资源体积
### 收效显著：减少打包体积
1. vite打包工具帮助我们压缩代码
2. 异步加载非紧急资源
>面试话语：例如：页面有一个压缩图片功能，而这个功能的第三方库很大；
>    这个功能用户不会立即使用、甚至可能不使用。将该功能异步加载
3. 更新依赖版本
>面试话语：  现在的打包工具有剪枝的功能shaking，也就是按需导入、按需打包。
>    一些库的老版本不支持按需引入，而新版本库可能支持按需引入。
>    我一一排查了老项目的依赖项，将它们更新到支持按需导入的新版本，这样子就减少了包的体积，提高首屏速度。
4. 能不用第三方库就不用第三方库
   例如：比较简单易实现的时间格式化函数，可能你自己写一写代码，不到1kb,但如果你引入第三方库，那么少说10kb。所以综合考虑。
>面试话语： 项目中一些用处不大的工具方法，它原本使用第三方库，我就自己写，优化了代码结构，这样子就减少了代码体积
5. 避免将大图片等媒体资源转为 base64，防止增大 JS 或 CSS 文件体积。
   项目打包工具默认会将图片转为 base64 格式嵌入 JS 或 CSS 文件中，对于小图标这样做影响不大，但大图片转 base64 会使 JS 体积增大。而图片加载不阻碍页面渲染，大图片无需转 base64，检查项目中是否存在大图片转 base64 的情况，避免因此导致的首屏资源体积增大。
### 收效不大的考虑：
1. 页面包含大量DOM分批随滚动渲染
2. 实在没有办法的办法，制作骨架屏或 loading 遮罩，减少用户等待焦虑。
>面试话语：有的页面实在是因为业务关系，经过优化后资源体积仍然较大，所以我做了骨架屏或 loading 遮罩，减少用户等待焦虑

# 操作速度、渲染速度
## 什么情况下会造成操作卡顿和渲染慢
1,一次性操作大量dom
2,进行了复杂度很高的运算（常见于循环）【不常见，通常不需要前端处理运算】
3,vue和react项目中，不必要的渲染太多
### 1.一次性操作大量DOM：
参考长列表渲染、大数据量渲染方法
### 3,vue和react项目中，不必要的渲染太多
Vue中有依赖收集，配合上vue3的静态节点标记，已经基本上避免了因为数据改变引起的无意义渲染。只有一些小点可以参考回答
l,频繁切换的显隐的内容用v-show也就是display来控制隐藏，只有打开就一次性决定显示与否的用v-if不去创建
2,循环，动态切换内容加好key值
3,keep-alive缓存(慎用，很多时候随着业务发展你会发现页面不更新带来的困扰大于你做缓存优化带来的优化)
4,区分请求粒度，减少请求范围，也能减少更新 --检查、减少不必要的更新请求
# 数据缓存
### 缓存不变数据、定期时效数据
可以缓存在cookies?或者localstorage中，比如token,用户名等
可以考虑做一个缓存队列，存于内存中(全局对象，Vuex)。这样能保证刷新就更新数据，也能一定程度上缓存数据

# 其他方法
## 懒加载
**图片/视频延迟加载**：当用户滚动到可视区域时才加载内容
注意：设置图片尺寸防止布局偏移
**应用场景**：
- 商品列表页（如淘宝）
    
- 社交媒体瀑布流（如Instagram）
    
- 长文档配图（如Medium博客）

## CDN

### 1. **资源部署方案**

| 资源类型     | 是否推荐CDN | 示例路径                     |
| -------- | ------- | ------------------------ |
| 图片/视频    | ✅ 必须    | /cdn/images/project1.jpg |
| CSS/JS文件 | ✅ 强烈推荐  | /cdn/js/main.abc123.js   |
| 字体文件     | ✅ 推荐    | /cdn/fonts/arial.woff2   |
#### **① 选择CDN服务**

- **免费方案**：Cloudflare（全球节点，自带缓存）
    
- **付费方案**：阿里云CDN/AWS CloudFront（更高性能）
    
#### **② 上传资源到CDN**
#### **③ 配置资源引用**
示例：
```html
<!-- 本地开发环境 -->
<img src="/images/photo.jpg">

<!-- 生产环境自动替换为CDN地址 -->
<img src="https://cdn.yourdomain.com/images/photo.jpg">
```


### **CDN缓存规则建议**

| 文件类型   | 缓存时间 | 示例配置                            |
| ------ | ---- | ------------------------------- |
| 图片/视频  | 1年   | Cache-Control: max-age=31536000 |
| CSS/JS | 6个月  | max-age=15552000, immutable     |
| HTML文档 | 5分钟  | max-age=300, must-revalidate    |
## 预加载（Preload）
方案：对于关键字体资源、CSS、首屏图片资源、核心JS，进行预加载
### **技术对比**

| 技术           | 触发时机     | 执行动作   | 典型用例           |
| ------------ | -------- | ------ | -------------- |
| `preload`    | HTML解析初期 | 仅下载不执行 | 关键字体/首屏图片      |
| `prefetch`   | 浏览器空闲时   | 下载+缓存  | 预测用户下一步可能访问的资源 |
| `preconnect` | DNS解析阶段  | 建立连接   | 第三方域名提前握手      |
#### 2. **需要避免的误用**

- ❌ 预加载非关键资源（如页面底部的图标）
    
- ❌ 对已缓存的资源重复预加载
    
- ❌ 忘记添加`crossorigin`属性（字体必须加）
    

#### 3. **动态检测预加载效果**
```javascript
// 检查预加载资源是否命中缓存
const font = new FontFace('MyFont', 'url(/fonts/resume.woff2)');
font.load().then(() => {
  console.log('字体已提前加载完成');
});
```

